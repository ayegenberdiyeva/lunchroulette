# Lunch Roulette - Приложение для случайного выбора места для обеда

## Краткое описание проекта

**Lunch Roulette** - это мобильное приложение для iOS, которое помогает пользователям решить вечную проблему "Куда пойти на обед?". Приложение позволяет пользователю указать свои предпочтения (кухня, средний чек, максимальное время ожидания), а затем случайным образом выбирает подходящее заведение из базы данных мест в Алматы. Также приложение сохраняет историю выбранных мест.

Проект состоит из двух частей:
1.  **iOS Frontend:** Написан на Swift с использованием SwiftUI и Combine. Отвечает за пользовательский интерфейс, взаимодействие с пользователем и отображение данных.
2.  **Backend API:** Написан на Python с использованием Django и Django REST Framework. Предоставляет API для получения списка заведений, их фильтрации и случайного выбора. В качестве базы данных используется SQLite.

## Инструкции по установке и запуску

Для работы приложения необходимо настроить и запустить обе части: бэкенд и фронтенд.

### Бэкенд (Django API)

1.  **Клонируйте репозиторий:**
    ```bash
    git clone <URL_вашего_репозитория>
    cd <папка_с_проектом>/backend # Перейдите в папку с бэкендом
    ```
2.  **Создайте и активируйте виртуальное окружение:**
    ```bash
    python -m venv venv
    # Windows
    # venv\Scripts\activate
    # macOS/Linux
    source venv/bin/activate
    ```
3.  **Установите зависимости:**
    ```bash
    pip install -r requirements.txt
    # Убедитесь, что у вас есть файл requirements.txt с Django, djangorestframework, django-filter и т.д.
    # Если файла нет, создайте его: pip freeze > requirements.txt
    ```
4.  **Примените миграции базы данных:**
    ```bash
    python manage.py migrate
    ```
5.  **(Опционально) Создайте суперпользователя для доступа к админ-панели:**
    ```bash
    python manage.py createsuperuser
    ```
    Следуйте инструкциям для задания логина и пароля. Админка доступна по адресу `/admin/`.
6.  **(Рекомендуется) Заполните базу данных начальными данными:**
    * Запустите Django shell:
        ```bash
        python manage.py shell
        ```
    * Внутри shell импортируйте модели и создайте объекты `Cuisine`, а затем `LunchSpot`, используя предоставленный Python-код (см. предыдущие ответы).
    * Либо используйте админ-панель (`/admin/`) для добавления данных вручную.
7.  **Запустите сервер разработки Django:**
    ```bash
    python manage.py runserver
    ```
    По умолчанию сервер будет доступен по адресу `http://127.0.0.1:8000/`. API эндпоинты будут доступны по адресу `http://127.0.0.1:8000/api/`.

### Фронтенд (iOS App)

1.  **Клонируйте репозиторий (если еще не сделали):**
    ```bash
    git clone <URL_вашего_репозитория>
    cd <папка_с_проектом>/frontend # Перейдите в папку с фронтендом
    ```
2.  **Откройте проект в Xcode:**
    Найдите файл `.xcodeproj` или `.xcworkspace` и откройте его с помощью Xcode.
3.  **Настройте базовый URL API:**
    * Откройте файл `NetworkManager.swift`.
    * Найдите строку `private let baseURL = ...`
    * Убедитесь, что URL соответствует адресу вашего запущенного бэкенда (например, `http://127.0.0.1:8000/api/`).
4.  **(Важно) Настройте App Transport Security (ATS):**
    * Если ваш бэкенд работает по `http` (а не `https`), вам нужно разрешить приложению подключаться к небезопасным URL.
    * Откройте файл `Info.plist` в Xcode.
    * Добавьте новый ключ `App Transport Security Settings` (тип Dictionary).
    * Внутри этого словаря добавьте ключ `Allow Arbitrary Loads` (тип Boolean) и установите его значение в `YES`.
5.  **Соберите и запустите приложение:**
    * Выберите целевое устройство (симулятор или подключенный iPhone/iPad).
    * Нажмите кнопку "Run" (▶) в Xcode.
    * Убедитесь, что устройство/симулятор имеет сетевой доступ к вашему бэкенду.

## Описание процесса проектирования и разработки

1.  **Идея:** Создать простое приложение для помощи в выборе места для обеда в Алматы, с возможностью фильтрации и элементом случайности.
2.  **Выбор стека:** Определены технологии: Swift/SwiftUI для iOS и Python/Django/DRF для бэкенда (обоснование ниже).
3.  **Проектирование Backend:**
    * Определены основные сущности: `Cuisine` (Кухня) и `LunchSpot` (Место для обеда).
    * Созданы модели Django с соответствующими полями.
    * Разработан API с использованием Django REST Framework:
        * Сериализаторы (`CuisineSerializer`, `LunchSpotSerializer`) для преобразования данных в JSON.
        * ViewSet (`LunchSpotViewSet`) для обработки запросов к `/api/lunch_spots/`. Реализована фильтрация по кухне (`cuisine__slug`), среднему чеку (`price_range`), времени ожидания (`max_waiting_time`) и возможность получения случайного элемента (`random=true`).
    * Настроены URL-маршруты.
    * Выбрана база данных SQLite для простоты разработки.
4.  **Проектирование Frontend:**
    * Разработан пользовательский интерфейс с использованием SwiftUI:
        * `ContentView`: главный экран с фильтрами и кнопкой выбора.
        * `LunchCard`: экран для отображения деталей выбранного заведения.
        * `HistoryView`: экран для просмотра истории выбора.
        * Вспомогательные View (`FlowButtons`, `WaitingTimePicker`, `SectionTitle`) для переиспользования элементов UI.
    * Реализована модель данных (`LunchSpot`, `Cuisine`, `Enums`) для соответствия API и удобства работы в UI.
    * Создан `NetworkManager` для инкапсуляции сетевых запросов к API.
    * Использован `LunchViewModel` (подход MVVM) для управления состоянием, логикой загрузки данных и взаимодействием между View и Model/Network.
    * Реализован `LunchHistoryManager` для сохранения и загрузки истории выбора в локальный JSON-файл.
5.  **Интеграция и Тестирование:**
    * Frontend подключен к Backend API.
    * Проведена отладка запросов и ответов, корректировка моделей данных Swift для соответствия JSON ответам API (включая `CodingKeys`).
    * Добавлена обработка ошибок сети и API.
    * Протестированы основные сценарии использования: выбор фильтров, получение случайного заведения, просмотр деталей, просмотр истории, обработка ошибок (например, "не найдено").

## Уникальные подходы или методологии

Хотя проект использует в основном стандартные современные практики, можно выделить:

* **Декларативный UI (SwiftUI):** Использование SwiftUI позволило быстро создавать и итерировать пользовательский интерфейс с меньшим количеством кода по сравнению с UIKit.
* **Реактивное программирование (Combine):** Применение Combine в `NetworkManager` и `LunchViewModel` для управления асинхронными сетевыми запросами и обновлениями состояния UI.
* **RESTful API (DRF):** Использование Django REST Framework значительно ускорило разработку API благодаря встроенным инструментам (сериализаторы, viewsets, фильтры).
* **Разделение ответственности:** Четкое разделение на Frontend и Backend, а также использование паттерна MVVM на фронтенде и сервисного слоя (`NetworkManager`, `HistoryManager`) помогает поддерживать чистоту и модульность кода.

## Обсуждение компромиссов

В процессе разработки были приняты следующие компромиссы:

* **База данных SQLite:** Выбрана для простоты и скорости развертывания на этапе разработки. Для реального приложения с большим количеством пользователей или одновременных записей предпочтительнее было бы использовать более масштабируемую БД, например, PostgreSQL.
* **Локальное хранение истории:** История сохраняется в JSON-файл на устройстве. Это простое решение, но история не синхронизируется между устройствами и может быть потеряна при удалении приложения. Альтернативы: CoreData, Realm или хранение истории на сервере.
* **Обработка ошибок:** Реализована базовая обработка сетевых ошибок и ошибок API (например, "не найдено"). Можно было бы добавить более детальную обратную связь для пользователя или логирование.
* **Отсутствие аутентификации:** API и приложение не требуют входа пользователя. Для публичного приложения или для персонализированных функций (например, "избранное") потребовалась бы система аутентификации.
* **Валидация URL:** Проверяется только базовая возможность создания URL из строк `mapUrl` и `menuUrl`. Не проверяется доступность этих URL или их реальное содержимое.
* **Фильтр "60+ мин":** Текущая реализация фильтра по времени ожидания поддерживает только "до X минут". Для реализации "60 минут и более" потребовались бы изменения в логике API бэкенда.

## Описание известных ошибок или проблем

* Приложение не предоставляет специфической обратной связи, если бэкенд-сервер недоступен (отображается общая сетевая ошибка).
* Если в базу данных для `mapUrl` или `menuUrl` будут внесены невалидные (но синтаксически корректные) строки, ссылки в приложении могут не работать, но приложение не упадет.
* История выбора доступна только на том устройстве, где она была создана.
* Фильтр времени ожидания "Более 60 мин" фактически работает как "До 60 минут" из-за ограничений текущей реализации API.

## Объяснение выбора технического стека

* **iOS Frontend (Swift, SwiftUI, Combine):**
    * **Swift:** Современный, безопасный и производительный язык от Apple, стандарт для нативной iOS-разработки.
    * **SwiftUI:** Декларативный фреймворк для создания UI, который упрощает и ускоряет разработку интерфейсов для всех платформ Apple. Позволяет создавать динамичные и красивые интерфейсы с меньшим количеством кода.
    * **Combine:** Фреймворк Apple для реактивного программирования, отлично интегрируется со SwiftUI для управления асинхронными операциями (сетевые запросы, таймеры) и потоками данных.
    * **Нативность:** Выбор нативного стека обеспечивает лучшую производительность, доступ ко всем возможностям ОС и наиболее привычный пользовательский опыт для владельцев iOS-устройств.

* **Backend (Python, Django, Django REST Framework, SQLite):**
    * **Python:** Очень популярный, гибкий язык с огромной экосистемой библиотек и сильным сообществом. Отлично подходит для веб-разработки.
    * **Django:** Мощный "batteries-included" веб-фреймворк, который предоставляет множество готовых компонентов (ORM, админка, система миграций, безопасность), что значительно ускоряет разработку бэкенда.
    * **Django REST Framework (DRF):** Стандарт де-факто для создания REST API на Django. Упрощает сериализацию данных, создание эндпоинтов, обработку запросов, аутентификацию и многое другое.
    * **SQLite:** Простая файловая база данных, идеально подходящая для разработки, тестирования и небольших приложений, не требующая отдельного сервера БД.
    * **Сочетание:** Python/Django - это зрелый, надежный и продуктивный стек для создания веб-приложений и API.
